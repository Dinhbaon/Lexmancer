using Godot;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Lexmancer.Abilities.V2;

namespace Lexmancer.Elements;

/// <summary>
/// Generates element abilities using LLM
/// Bridges the gap between element system and primitive-based LLM generation
/// </summary>
public class LLMElementGenerator
{
	private readonly bool useLLM;
	private readonly LLMClientV2 llmClient;

	public LLMElementGenerator(
		string playerId = "player_001",
		bool useLLM = true,
		string llmBaseUrl = "http://localhost:11434",
		string llmModel = "qwen2.5:7b")
	{
		this.useLLM = useLLM;

		if (useLLM)
		{
			llmClient = new LLMClientV2(llmBaseUrl, llmModel);
			GD.Print($"LLMElementGenerator initialized with LLM enabled ({llmModel})");
		}
		else
		{
			GD.Print("LLMElementGenerator initialized with LLM disabled (using fallbacks)");
		}
	}

	/// <summary>
	/// Check if a combination has been generated before (cached in ElementRegistry)
	/// Returns the cached element if found, otherwise null
	/// </summary>
	public Element GetCachedCombination(int element1Id, int element2Id)
	{
		// Check ElementRegistry for all previously generated combinations
		var allElements = ElementRegistry.GetAllElements();

		foreach (var element in allElements)
		{
			// Check if this element was created from these two ingredients (in either order)
			if (element.Recipe != null && element.Recipe.Count == 2)
			{
				bool isMatch = (element.Recipe[0] == element1Id && element.Recipe[1] == element2Id) ||
				               (element.Recipe[0] == element2Id && element.Recipe[1] == element1Id);

				if (isMatch)
				{
					GD.Print($"Found cached combination: {element.Name}");
					return element;
				}
			}
		}

		return null;
	}

	/// <summary>
	/// Generate a completely new element from combining two elements (name + ability)
	/// This is the main method for dynamic element creation!
	/// </summary>
	public async Task<Element> GenerateElementFromCombinationAsync(int element1Id, int element2Id, bool forceNew = false)
	{
		if (!useLLM)
		{
			GD.PrintErr("LLM is disabled - cannot generate dynamic elements");
			return null;
		}

		try
		{
			// Get elements from registry
			Element elem1 = ElementRegistry.GetElement(element1Id);
			Element elem2 = ElementRegistry.GetElement(element2Id);

			if (elem1 == null || elem2 == null)
			{
				GD.PrintErr($"Cannot find elements: {element1Id}, {element2Id}");
				return null;
			}

			GD.Print($"ðŸ”® Generating NEW element from {elem1.Name} + {elem2.Name}...");

			// Generate the element and ability using LLM
			var result = await GenerateElementWithLLMAsync(elem1, elem2);

			GD.Print($"âœ¨ Created element: {result.Name}");

			return result;
		}
		catch (Exception ex)
		{
			GD.PrintErr($"Failed to generate element combination: {ex.Message}");
			return null;
		}
	}

	/// <summary>
	/// Use LLM to generate element name, description, color, and ability
	/// </summary>
	private async Task<Element> GenerateElementWithLLMAsync(Element elem1, Element elem2)
	{
		var prompt = BuildElementGenerationPrompt(elem1, elem2);

		GD.Print($"Sending element generation request to LLM...");

		// Call LLM with full element information
		var response = await llmClient.GenerateElementAsync(
			elem1.Name,
			elem2.Name,
			elem1.Description,
			elem2.Description);

		// Serialize to JSON for debugging
		var options = new JsonSerializerOptions { WriteIndented = true };
		var jsonString = JsonSerializer.Serialize(response, options);
		GD.Print($"LLM JSON Response:\n{jsonString}");

		// Parse response into Element (dynamic element, no primitive type)
		// ID will be auto-assigned by database when cached
		var newElement = new Element
		{
			// Id is auto-generated by database - don't set it
			Primitive = null,  // Dynamic elements don't have a primitive type
			Name = response.Name,
			Description = response.Description,
			ColorHex = response.ColorHex,
			Tier = 2,
			Recipe = new List<int> { elem1.Id, elem2.Id },
			Ability = response.Ability
		};

		return newElement;
	}

	/// <summary>
	/// Build creative prompt for element generation
	/// </summary>
	private string BuildElementGenerationPrompt(Element elem1, Element elem2)
	{
		return $@"You are a creative game designer creating magical elements for a roguelike game.

Two base elements are being combined:
- {elem1.Name}: {elem1.Description}
- {elem2.Name}: {elem2.Description}

Generate a NEW, UNIQUE element that emerges from this combination.

IMPORTANT GUIDELINES:
- Be CREATIVE! Think beyond obvious combinations
- {elem1.Name} + {elem2.Name} could create MANY different results
- Consider physical, magical, conceptual, and thematic combinations
- Each generation should feel unique and interesting

Examples of creative thinking:
- Fire + Earth could be: Lava, Magma, Hellstone, Obsidian, Ashrock, Cinders, Molten Core
- Water + Fire could be: Steam, Mist, Boiling Water, Thermal Vent, Geysir, Scalding Fog
- Earth + Water could be: Mud, Clay, Quicksand, Swamp, Silt, Fertile Soil

Generate the element with these properties:
1. Name (1-2 words, evocative and unique)
2. Description (1-2 sentences describing what it is)
3. Color (hex code like #FF5500)
4. An ability (using the effect scripting system)

Return as JSON.";
	}
}
