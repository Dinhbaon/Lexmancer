using Godot;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Lexmancer.Abilities.V2;
using Lexmancer.Core;
using Lexmancer.Services;

namespace Lexmancer.Elements;

/// <summary>
/// Generates element abilities using LLM
/// </summary>
public class LLMElementGenerator
{
    private bool useLLM;
    private readonly LLMClientV2 llmClient;

    public LLMElementGenerator(
        string playerId = "player_001",
        bool useLLM = true,
        string llmBaseUrl = "http://localhost:11434",
        string llmModel = "qwen2.5:7b",
        LLMClientV2 llmClient = null)
    {
        this.useLLM = useLLM;

        // Allow DI of a shared client so transport selection is centralized.
        if (llmClient != null)
        {
            this.llmClient = llmClient;
            if (useLLM)
                GD.Print("LLMElementGenerator using injected client");
        }
        else if (useLLM)
        {
            this.llmClient = new LLMClientV2(llmBaseUrl, llmModel);
            GD.Print($"LLMElementGenerator initialized with LLM enabled ({llmModel})");
        }

        if (!useLLM)
        {
            GD.Print("LLMElementGenerator initialized with LLM disabled");
        }
    }

    /// <summary>
    /// Enable/disable LLM usage at runtime.
    /// </summary>
    public void SetUseLLM(bool enabled) => useLLM = enabled;

	/// <summary>
	/// Check if a combination has been generated before (cached in ElementService)
	/// Returns the cached element if found, otherwise null
	/// </summary>
	public Element GetCachedCombination(int element1Id, int element2Id)
	{
		// Check ElementService for all previously generated combinations
		var allElements = ServiceLocator.Instance.Elements.GetAllElements();

		foreach (var element in allElements)
		{
			// Check if this element was created from these two ingredients (in either order)
			if (element.Recipe != null && element.Recipe.Count == 2)
			{
				bool isMatch = (element.Recipe[0] == element1Id && element.Recipe[1] == element2Id) ||
				               (element.Recipe[0] == element2Id && element.Recipe[1] == element1Id);

				if (isMatch)
				{
					GD.Print($"Found cached combination: {element.Name}");
					return element;
				}
			}
		}

		return null;
	}

	/// <summary>
	/// Generate a completely new element from combining two elements (name + ability)
	/// This is the main method for dynamic element creation!
	/// Uses LLM to generate everything.
	/// </summary>
	public async Task<Element> GenerateElementFromCombinationAsync(int element1Id, int element2Id, bool forceNew = false)
	{
		try
		{
			// Get elements from service
			Element elem1 = ServiceLocator.Instance.Elements.GetElement(element1Id);
			Element elem2 = ServiceLocator.Instance.Elements.GetElement(element2Id);

			if (elem1 == null || elem2 == null)
			{
				GD.PrintErr($"Cannot find elements: {element1Id}, {element2Id}");
				return null;
			}

			if (!useLLM)
			{
				GD.PrintErr("LLM is disabled - cannot generate elements");
				return null;
			}

			GD.Print("Using Full LLM generation mode");
			GD.Print($"ðŸ”® Generating NEW element from {elem1.Name} + {elem2.Name}...");
			var result = await GenerateElementWithLLMAsync(elem1, elem2);
			GD.Print($"âœ¨ Created element: {result.Name}");
			return result;
		}
		catch (Exception ex)
		{
			GD.PrintErr($"Failed to generate element combination: {ex.Message}");
			GD.PrintErr($"Stack trace: {ex.StackTrace}");
			return null;
		}
	}

	/// <summary>
	/// Use LLM to generate element name, description, color, and ability
	/// </summary>
	private async Task<Element> GenerateElementWithLLMAsync(Element elem1, Element elem2)
	{
		var prompt = BuildElementGenerationPrompt(elem1, elem2);

		GD.Print($"Sending element generation request to LLM...");

		// Call LLM with full element information
		var response = await llmClient.GenerateElementAsync(
			elem1.Name,
			elem2.Name,
			elem1.Description,
			elem2.Description);

		// Serialize to JSON for debugging
		var options = new JsonSerializerOptions { WriteIndented = true };
		var jsonString = JsonSerializer.Serialize(response, options);
		GD.Print($"LLM JSON Response:\n{jsonString}");

		// Parse response into Element (dynamic element, no primitive type)
		// ID will be auto-assigned by database when cached
		var newElement = new Element
		{
			// Id is auto-generated by database - don't set it
			Primitive = null,  // Dynamic elements don't have a primitive type
			Name = response.Name,
			Description = response.Description,
			ColorHex = response.ColorHex,
			Tier = 2,
			Recipe = new List<int> { elem1.Id, elem2.Id },
			Ability = response.Ability
		};

		return newElement;
	}

	/// <summary>
	/// Build creative prompt for element generation
	/// </summary>
	private string BuildElementGenerationPrompt(Element elem1, Element elem2)
	{
		return $@"You are a creative game designer creating magical elements for a roguelike game.

Two base elements are being combined:
- {elem1.Name}: {elem1.Description}
- {elem2.Name}: {elem2.Description}

Generate a NEW, UNIQUE element that emerges from this combination.

IMPORTANT GUIDELINES:
- Be CREATIVE! Think beyond obvious combinations
- {elem1.Name} + {elem2.Name} could create MANY different results
- Consider physical, magical, conceptual, and thematic combinations
- Each generation should feel unique and interesting

Examples of creative thinking:
- Fire + Earth could be: Lava, Magma, Hellstone, Obsidian, Ashrock, Cinders, Molten Core
- Water + Fire could be: Steam, Mist, Boiling Water, Thermal Vent, Geysir, Scalding Fog
- Earth + Water could be: Mud, Clay, Quicksand, Swamp, Silt, Fertile Soil

Generate the element with these properties:
1. Name (1-2 words, evocative and unique)
2. Description (1-2 sentences describing what it is)
3. Color (hex code like #FF5500)
4. An ability (using the effect scripting system)

Return as JSON.";
	}

	/// <summary>
	/// Hash two element IDs to create a deterministic seed
	/// </summary>
	private int HashElements(int id1, int id2)
	{
		// Sort IDs to ensure same seed regardless of order
		int min = Math.Min(id1, id2);
		int max = Math.Max(id1, id2);
		return (min * 1000) + max;
	}
}
